data Unit where
  | U : Unit
end

data Foo (u : Unit) where
  | FooCon (u : Unit) : Foo u
end

let un : Unit
  = case U || FooCon U
    motive (u : Unit) || (f : Foo u) || Unit
    of
    | x || FooCon .x -> U
    end
end

data Inv (a : Type) (b : Type) (f : (x : a) -> b) (y : b) where
  | InvEl (a : Type) (b : Type) (f : (x : a) -> b) (x : a) : Inv a b f (f x)
end

data Bool where
  | True : Bool
  | False : Bool
end

let not : (b : Bool) -> Bool
  = \b -> case b
          motive (b' : Bool) || Bool
          of
           | True -> False
           | False -> True
          end
end

let ex : Inv Bool Bool not True
  = InvEl Bool Bool not False
end

data Nat where
  | Zero : Nat
  | Suc (n : Nat) : Nat
end

let plusOne : (n : Nat) -> Nat
  = \n -> Suc n
end

let ex2 : Inv Nat Nat (\n -> Suc n) (Suc Zero)
  = InvEl Nat Nat plusOne Zero
end